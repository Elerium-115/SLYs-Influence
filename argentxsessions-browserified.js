(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ArgentXSessions = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const argentXSessions = require("@argent/x-sessions");
module.exports = {argentXSessions};
},{"@argent/x-sessions":2}],2:[function(require,module,exports){
(function(u,n){typeof exports=="object"&&typeof module<"u"?n(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],n):(u=typeof globalThis<"u"?globalThis:u||self,n(u.sessions={},u.starknet))})(this,function(u,n){"use strict";const I="https://cloud.argent-api.com/v1";class w extends Error{constructor(t,e){super(t),this.cause=e,Error.captureStackTrace(this,this.constructor)}}class A{constructor(t,e,i=I){this.pubkey=t,this.accountSessionSignature=e,this.argentSessionServiceBaseUrl=i}async signTxAndSession(t,e,i,o,r){const a=n.transaction.getExecuteCalldata(t,e.cairoVersion),c=n.typedData.getMessageHash(i,e.walletAddress),d=n.stark.formatSignature(this.accountSessionSignature),p={session:{sessionHash:c,sessionAuthorisation:d,cacheAuthorisation:r,sessionSignature:{type:"StarknetKey",signer:{publicKey:this.pubkey,r:o[0].toString(),s:o[1].toString()}}}};if(Object.values(n.RPC.ETransactionVersion2).includes(e.version)){const l=e;p.transaction={contractAddress:l.walletAddress,calldata:a,maxFee:l.maxFee.toString(),nonce:l.nonce.toString(),version:n.num.toBigInt(l.version).toString(10),chainId:n.num.toBigInt(l.chainId).toString(10)}}else if(Object.values(n.RPC.ETransactionVersion3).includes(e.version)){const l=e;p.transaction={sender_address:l.walletAddress,calldata:a,nonce:l.nonce.toString(),version:n.num.toBigInt(l.version).toString(10),chainId:n.num.toBigInt(l.chainId).toString(10),resource_bounds:{l1_gas:{max_amount:l.resourceBounds.l1_gas.max_amount.toString(),max_price_per_unit:l.resourceBounds.l1_gas.max_price_per_unit.toString()},l2_gas:{max_amount:l.resourceBounds.l1_gas.max_amount.toString(),max_price_per_unit:l.resourceBounds.l1_gas.max_price_per_unit.toString()}},tip:l.tip.toString(),paymaster_data:l.paymasterData.map(H=>H.toString()),account_deployment_data:l.accountDeploymentData,nonce_data_availability_mode:l.nonceDataAvailabilityMode,fee_data_availability_mode:l.feeDataAvailabilityMode}}else throw Error("unsupported signTransaction version");const g=await fetch(`${this.argentSessionServiceBaseUrl}/cosigner/signSession`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(p)});if(!g.ok){const l=await g.json();throw new w("Sign session error",l.status)}return(await g.json()).signature}async signSessionEFO(t,e,i,o,r,a){const c=n.typedData.getMessageHash(_(t,a),e),d=n.stark.formatSignature(this.accountSessionSignature),g={session:{sessionHash:c,sessionAuthorisation:d,cacheAuthorisation:r,sessionSignature:{type:"StarknetKey",signer:{publicKey:this.pubkey,r:o[0].toString(),s:o[1].toString()}}},message:{type:"eip712",accountAddress:e,chain:"starknet",message:i}},h=JSON.stringify(g,(M,T)=>typeof T=="bigint"?T.toString():T),l=await fetch(`${this.argentSessionServiceBaseUrl}/cosigner/signSessionEFO`,{method:"POST",headers:{"Content-Type":"application/json"},body:h});if(!l.ok){const M=await l.json();throw new w("Sign session error",M.status)}return(await l.json()).signature}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0),BigInt(1),BigInt(2);function B(s){return s instanceof Uint8Array||s!=null&&typeof s=="object"&&s.constructor.name==="Uint8Array"}const j=Array.from({length:256},(s,t)=>t.toString(16).padStart(2,"0"));function P(s){if(!B(s))throw new Error("Uint8Array expected");let t="";for(let e=0;e<s.length;e++)t+=j[s[e]];return t}const E={StarknetDomain:[{name:"name",type:"shortstring"},{name:"version",type:"shortstring"},{name:"chainId",type:"shortstring"},{name:"revision",type:"shortstring"}],OutsideExecution:[{name:"Caller",type:"ContractAddress"},{name:"Nonce",type:"felt"},{name:"Execute After",type:"u128"},{name:"Execute Before",type:"u128"},{name:"Calls",type:"Call*"}],Call:[{name:"To",type:"ContractAddress"},{name:"Selector",type:"selector"},{name:"Calldata",type:"felt*"}]};function K(s){return{name:"Account.execute_from_outside",version:"1",chainId:s,revision:"1"}}function v(s){return{to:s.contractAddress,selector:n.hash.getSelectorFromName(s.entrypoint),calldata:s.calldata??[]}}function F(s,t,e){return n.typedData.getMessageHash(m(s,e),t)}function m(s,t){return{types:E,primaryType:"OutsideExecution",domain:K(t),message:{Caller:s.caller,Nonce:s.nonce,"Execute After":s.execute_after,"Execute Before":s.execute_before,Calls:s.calls.map(e=>({To:e.to,Selector:e.selector,Calldata:e.calldata}))}}}async function N(s,t,e,i,o){o=o??await i.getChainId();const r=m(s,o),a=await e.signMessage(r,t);return{contractAddress:t,entrypoint:"execute_from_outside_v2",calldata:n.CallData.compile({...s,signature:a})}}var y=(s=>(s[s.Starknet=0]="Starknet",s[s.Secp256k1=1]="Secp256k1",s[s.Secp256r1=2]="Secp256r1",s[s.Eip191=3]="Eip191",s[s.Webauthn=4]="Webauthn",s))(y||{});const k=(s,t)=>{const e={Starknet:void 0,Secp256k1:void 0,Secp256r1:void 0,Eip191:void 0,Webauthn:void 0};if(s===y.Starknet)e.Starknet=t;else if(s===y.Secp256k1)e.Secp256k1=t;else if(s===y.Secp256r1)e.Secp256r1=t;else if(s===y.Eip191)e.Eip191=t;else if(s===y.Webauthn)e.Webauthn=t;else throw new Error("Unknown SignerType");return new n.CairoCustomEnum(e)},x=n.shortString.encodeShortString("session-token");class V extends n.Signer{constructor(t){super(),this.signTransactionCallback=t}async signRaw(t){throw new Error("Method not implemented.")}async signTransaction(t,e){return this.signTransactionCallback(t,e)}}class b{constructor(t,e,i){this.argentSessionService=t,this.chainId=e,this.dappKey=i}getAccountWithSessionSigner(t,e,i,o,r=!1){const a=new V((c,d)=>this.signTransaction(o,i,c,d,r));return new n.Account(t,e,a)}async signTransaction(t,e,i,o,r){const a=n.transaction.getExecuteCalldata(i,o.cairoVersion);let c;if(Object.values(n.RPC.ETransactionVersion2).includes(o.version)){const d=o;c=n.hash.calculateInvokeTransactionHash({...d,senderAddress:d.walletAddress,compiledCalldata:a,version:d.version})}else if(Object.values(n.RPC.ETransactionVersion3).includes(o.version)){const d=o;c=n.hash.calculateInvokeTransactionHash({...d,senderAddress:d.walletAddress,compiledCalldata:a,version:d.version,nonceDataAvailabilityMode:n.stark.intDAM(d.nonceDataAvailabilityMode),feeDataAvailabilityMode:n.stark.intDAM(d.feeDataAvailabilityMode)})}else throw Error("unsupported signTransaction version");return this.getSessionSignatureForTransaction(t,e,c,i,o.walletAddress,o,r)}async getSessionSignatureForTransaction(t,e,i,o,r,a,c){const d=this.compileSessionHelper(e),S=_(e,this.chainId),p=await this.signTxAndSession(i,r,S,c),g=await this.argentSessionService.signTxAndSession(o,a,S,p,c),h=await this.compileSessionTokenHelper(d,e,o,p,t,g,c);return[x,...n.CallData.compile(h)]}async signTxAndSession(t,e,i,o){const r=n.typedData.getMessageHash(i,e),a=n.hash.computePoseidonHashOnElements([t,r,+o]),c=n.ec.starkCurve.sign(a,this.dappKey.privateKey);return[c.r,c.s]}buildMerkleTree(t){const e=t.allowed_methods.map(i=>n.hash.computePoseidonHashOnElements([D,i["Contract Address"],n.selector.getSelectorFromName(i.selector)]));return new n.merkle.MerkleTree(e,n.hash.computePoseidonHash)}getSessionProofs(t,e){const i=this.buildMerkleTree(t);return e.map(o=>{const r=t.allowed_methods.findIndex(a=>a["Contract Address"]==o.contractAddress&&a.selector==o.entrypoint);return i.getProof(i.leaves[r],i.leaves)})}compileSessionHelper(t){const e=n.byteArray.byteArrayFromString(t.metadata),i=[e.data.length,...e.data,e.pending_word,e.pending_word_len],o=n.hash.computePoseidonHashOnElements(i);return{expires_at:t.expires_at,allowed_methods_root:this.buildMerkleTree(t).root.toString(),metadata_hash:o,session_key_guid:t.session_key_guid}}async compileSessionTokenHelper(t,e,i,o,r,a,c){return{session:t,cache_authorization:c,session_authorization:r,sessionSignature:this.getStarknetSignatureType(this.dappKey.publicKey,o),guardianSignature:this.getStarknetSignatureType(a.publicKey,[a.r,a.s]),proofs:this.getSessionProofs(e,i)}}getStarknetSignatureType(t,e){return k(y.Starknet,{pubkey:t,r:e[0],s:e[1]})}buildOutsideExecution(t,e,i,o,r){const a=n.shortString.encodeShortString("ANY_CALLER"),c=n.encode.addHexPrefix(P(n.ec.starkCurve.utils.randomPrivateKey())),d=Date.now(),S=Math.floor((d+6e4*20)/1e3),p=Math.floor((d-6e4*10)/1e3);return{caller:e||a,nonce:r||c,execute_after:i||p,execute_before:o||S,calls:t.map(g=>v(g))}}buildOutsideExecutionTypedData(t,e,i,o,r,a){const c=this.buildOutsideExecution(e,i,o,r,a);return m(c,t)}async getOutsideExecutionCall(t,e,i,o,r,a,c,d,S){const p=this.buildOutsideExecution(o,a,c,d,S),g=m(p,this.chainId),h=await this.getSessionSignatureForOutsideExecutionTypedData(e,t,o,r,g,i);return{contractAddress:r,entrypoint:"execute_from_outside_v2",calldata:n.CallData.compile({...p,signature:h})}}async getSessionSignatureForOutsideExecutionTypedData(t,e,i,o,r,a){const c=this.compileSessionHelper(e),d=_(e,this.chainId),S=n.typedData.getMessageHash(r,o),p=await this.signTxAndSession(S,o,d,a),g=await this.argentSessionService.signSessionEFO(e,o,r,p,a,this.chainId),h=await this.compileSessionTokenHelper(c,e,i,p,t,g,a);return[x,...n.CallData.compile(h)]}async getOutsideExecutionTypedData(t,e,i,o,r,a,c,d,S){const p=this.buildOutsideExecutionTypedData(this.chainId,o,a,c,d,S),g=await this.getSessionSignatureForOutsideExecutionTypedData(e,t,o,r,p,i);return{outsideExecutionTypedData:p,signature:g}}}const f={StarknetDomain:[{name:"name",type:"shortstring"},{name:"version",type:"shortstring"},{name:"chainId",type:"shortstring"},{name:"revision",type:"shortstring"}],"Allowed Method":[{name:"Contract Address",type:"ContractAddress"},{name:"selector",type:"selector"}],Session:[{name:"Expires At",type:"timestamp"},{name:"Allowed Methods",type:"merkletree",contains:"Allowed Method"},{name:"Metadata",type:"string"},{name:"Session Key",type:"felt"}]},D=n.typedData.getTypeHash(f,"Allowed Method",n.typedData.TypedDataRevision.Active),C=s=>({name:"SessionAccount.session",version:n.shortString.encodeShortString("1"),chainId:s,revision:"1"}),_=(s,t)=>({types:f,primaryType:"Session",domain:C(t),message:{"Expires At":s.expires_at,"Allowed Methods":s.allowed_methods,Metadata:s.metadata,"Session Key":s.session_key_guid}}),O=(s,t,e,i)=>({expires_at:Number(t),allowed_methods:s,metadata:JSON.stringify(e),session_key_guid:n.hash.computePoseidonHash(n.shortString.encodeShortString("Starknet Signer"),i)}),W=async({useCacheAuthorisation:s,accountSessionSignature:t,sessionRequest:e,provider:i,chainId:o,address:r,dappKey:a,argentSessionServiceBaseUrl:c})=>{const d=new A(a.publicKey,t,c);return new b(d,o,a).getAccountWithSessionSigner(i,r,e,t,s)},U=async({wallet:s,sessionParams:t,chainId:e})=>{const{allowedMethods:i,expiry:o=BigInt(Date.now())+10000n,publicDappKey:r,metaData:a}=t;if(!r)throw new Error("publicDappKey is required");const c=O(i,o,a,r),d=_(c,e);return await s.request({type:"wallet_signTypedData",params:d})};u.ALLOWED_METHOD_HASH=D,u.ArgentSessionService=A,u.SessionDappService=b,u.buildSessionAccount=W,u.createSessionRequest=O,u.getOutsideCall=v,u.getOutsideExecutionCall=N,u.getOutsideExecutionTypedData=m,u.getSessionDomain=C,u.getSessionTypedData=_,u.getTypedDataHash=F,u.openSession=U,u.sessionTypes=f,u.typesRev1=E,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});

},{"starknet":undefined}]},{},[1])(1)
});
